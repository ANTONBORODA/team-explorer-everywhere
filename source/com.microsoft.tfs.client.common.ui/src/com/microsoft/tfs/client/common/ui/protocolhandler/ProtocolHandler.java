// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See License.txt in the repository root.

package com.microsoft.tfs.client.common.ui.protocolhandler;

import java.net.URI;
import java.text.MessageFormat;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.microsoft.tfs.client.common.framework.command.ICommand;
import com.microsoft.tfs.client.common.git.utils.GitHelpers;
import com.microsoft.tfs.core.util.ServerURIUtils;
import com.microsoft.tfs.core.util.URIUtils;
import com.microsoft.tfs.util.Platform;
import com.microsoft.tfs.util.StringUtil;

/**
 *
 */
public class ProtocolHandler {
    private static final Log log = LogFactory.getLog(ProtocolHandler.class);

    private static final String GIT_TOKEN = "_git"; //$NON-NLS-1$
    private static final String DEFAULT_COLLECTION_TOKEN = "DefaultCollection"; //$NON-NLS-1$

    private final static String PROTOCOL_HANDLER_URL_PARAM = "url="; //$NON-NLS-1$
    private final static String PROTOCOL_HANDLER_ENCODING_PARAM = "EncFormat="; //$NON-NLS-1$
    private final static String PROTOCOL_HANDLER_BRANCH_PARAM = "Ref="; //$NON-NLS-1$

    public final static String PROTOCOL_HANDLER_ARG = "-clonefromtfs"; //$NON-NLS-1$
    public final static String PROTOCOL_HANDLER_SCHEME = "vsoi"; //$NON-NLS-1$

    private static final ProtocolHandler instance = new ProtocolHandler();

    private URI protocolHandlerUri;

    private boolean isParsed = false;
    private boolean isAvailable = false;
    private String cloneUrl;
    private String encoding;
    private String branchName;
    private String serverUrl;
    private String repository;
    private String project;

    public ProtocolHandler() {
        protocolHandlerUri = findProtocolHandlerUriArgument(org.eclipse.core.runtime.Platform.getApplicationArgs());
    }

    public static ProtocolHandler getInstance() {
        return instance;
    }

    public boolean hasProtocolHandlerRequest() {
        return isParsed ? isAvailable : protocolHandlerUri != null;
    }

    public String getProtocolHandlerServer() {
        tryParseProtocolHandlerUri();
        return isAvailable ? serverUrl : StringUtil.EMPTY;
    }

    public String getProtocolHandlerProject() {
        tryParseProtocolHandlerUri();
        return isAvailable ? project : StringUtil.EMPTY;
    }

    public String getProtocolHandlerBranch() {
        tryParseProtocolHandlerUri();
        return isAvailable ? branchName : StringUtil.EMPTY;
    }

    public String getProtocolHandlerRepository() {
        tryParseProtocolHandlerUri();
        return isAvailable ? repository : StringUtil.EMPTY;
    }

    public String getProtocolHandlerCloneUrl() {
        tryParseProtocolHandlerUri();
        return isAvailable ? cloneUrl.toString() : StringUtil.EMPTY;
    }

    public String getProtocolHandlerEncodedCloneUrl() {
        tryParseProtocolHandlerUri();
        return isAvailable ? URIUtils.newURI(cloneUrl).toASCIIString() : StringUtil.EMPTY;
    }

    private URI findProtocolHandlerUriArgument(final String[] applicationArgs) {
        if (applicationArgs == null) {
            return null;
        }
        boolean found = false;

        /*
         * @formatter:off
         * We're looking for a protocol handler argument among all command line
         * arguments passed by eclipse.launcher to the Eclipse application. The
         * protocol handler argument should have the following syntax:
         * 
         * -clonefromtfs <uri>
         * 
         * At this point we do not parse the value of the argument. We'll do it later.
         * @formatter:on
         */

        for (final String arg : applicationArgs) {
            if (found) {
                log.info(MessageFormat.format(
                    "Found the protocol handler argument: {0} {1}", //$NON-NLS-1$
                    PROTOCOL_HANDLER_ARG,
                    arg));

                try {
                    return URIUtils.newURI(arg);
                } catch (final Exception e) {
                    log.error("   Incorrect URL in the protocol handler argument", e); //$NON-NLS-1$
                }

                break;
            } else if (arg.equalsIgnoreCase(PROTOCOL_HANDLER_ARG)) {
                found = true;
            }
        }

        return null;
    }

    /*
     * @formatter:off
     * We're looking for a protocol handler argument among all command line
     * arguments passed by eclipse.launcher to the Eclipse application. The
     * protocol handler argument generated by TFS should have the following
     * syntax:
     * 
     * -clonefromtfs vsoe://<operation>/?url=<git-repository-url>&Ref=master&EncFormat=UTF8[&<other-parameters>...]
     * 
     * At this moment we use vsoi instead of vsoe, and ignore <operation> and
     * <other-parameters>
     * @formatter:on
     */
    private synchronized void tryParseProtocolHandlerUri() {
        if (isParsed) {
            return;
        }
        isParsed = true;

        if (protocolHandlerUri == null) {
            return;
        }

        if (!PROTOCOL_HANDLER_SCHEME.equalsIgnoreCase(protocolHandlerUri.getScheme())) {
            log.error(MessageFormat.format(
                "   Incorrect scheme in the protocol handler URL: {0}", //$NON-NLS-1$
                protocolHandlerUri.getScheme() == null ? "NULL" : protocolHandlerUri.getScheme())); //$NON-NLS-1$
            return;
        }

        boolean repoUrlAvailable = false;

        final String queryString = protocolHandlerUri.getQuery();
        if (StringUtil.isNullOrEmpty(queryString)) {
            log.error("   Incorrect (empty) query string in the protocol handler URL"); //$NON-NLS-1$
            return;
        }

        final String[] queryItems = queryString.split("&"); //$NON-NLS-1$

        for (final String queryItem : queryItems) {
            if (StringUtil.startsWithIgnoreCase(queryItem, PROTOCOL_HANDLER_URL_PARAM)) {
                final String value = queryItem.substring(PROTOCOL_HANDLER_URL_PARAM.length());

                log.info(MessageFormat.format(
                    "   Found query parameter: {0}{1}", //$NON-NLS-1$
                    PROTOCOL_HANDLER_URL_PARAM,
                    value));

                cloneUrl = value;
                repoUrlAvailable = tryParseGitRepoUrl(value);

            } else if (StringUtil.startsWithIgnoreCase(queryItem, PROTOCOL_HANDLER_ENCODING_PARAM)) {
                final String value = queryItem.substring(PROTOCOL_HANDLER_ENCODING_PARAM.length());

                log.info(MessageFormat.format(
                    "   Found query parameter: {0}{1}", //$NON-NLS-1$
                    PROTOCOL_HANDLER_ENCODING_PARAM,
                    value));

                encoding = value;

            } else if (StringUtil.startsWithIgnoreCase(queryItem, PROTOCOL_HANDLER_BRANCH_PARAM)) {
                final String value = queryItem.substring(PROTOCOL_HANDLER_BRANCH_PARAM.length());

                log.info(MessageFormat.format(
                    "   Found query parameter: {0}{1}", //$NON-NLS-1$
                    PROTOCOL_HANDLER_BRANCH_PARAM,
                    value));

                branchName = value;
            }
        }

        if (repoUrlAvailable) {
            isAvailable = true;
        } else {
            log.error(MessageFormat.format(
                "   Incorrect or missing {0} query parameter in the protocol handler URL", //$NON-NLS-1$
                PROTOCOL_HANDLER_URL_PARAM));
        }
    }

    private boolean tryParseGitRepoUrl(final String repoUrl) {
        final URI uri;
        try {
            uri = URIUtils.newURI(repoUrl);
        } catch (final Exception e) {
            log.error(
                "   Incorrect Git repository URL", //$NON-NLS-1$
                e);
            return false;
        }

        final String pathString = uri.getPath();
        if (StringUtil.isNullOrEmpty(pathString)) {
            log.error("   Incorrect (empty) path in the Git repository URL"); //$NON-NLS-1$
            return false;
        }

        final String[] pathItems = uri.getPath().split("/"); //$NON-NLS-1$
        int n = pathItems.length;

        if (n < 2) {
            log.error("   Too short path in the Git repository URL"); //$NON-NLS-1$
            return false;
        } else if (!GIT_TOKEN.equals(pathItems[n - 2])) {
            log.error("   The repository URL does not point to a TFS Git repository"); //$NON-NLS-1$
            return false;
        }

        final String scheme = uri.getScheme();
        final String authority = uri.getAuthority();
        String path;

        repository = pathItems[n - 1];

        // Note that because uri.getPath() is absolute, pathItems[0] is always
        // an empty string.
        if (ServerURIUtils.isHosted(uri)) {
            /*
             * @formatter off            
             * Possible URLs are:
             * https://account.visualstudio.com/_git/repository                           (n=3)
             * https://account.visualstudio.com/project/_git/repository                   (n=4) 
             * https://account.visualstudio.com/DefaultCollection/_git/repository         (n=4) 
             * https://account.visualstudio.com/DefaultCollection/project/_git/repository (n=5) 
             * in the future, "DefaultCollection" will be replaced with "Organization"
             * @formatter:on          
             */
            switch (n) {
                case 5:
                    project = pathItems[2];
                    path = '/' + pathItems[1];
                    break;
                case 4:
                    if (DEFAULT_COLLECTION_TOKEN.equalsIgnoreCase(pathItems[1])) {
                        project = repository;
                        path = '/' + pathItems[1];
                    } else {
                        project = pathItems[1];
                        path = null;
                    }
                    break;
                case 3:
                    project = repository;
                    path = null;
                    break;
                default:
                    log.error("   Too long path in the Git repository URL"); //$NON-NLS-1$
                    return false;
            }
        } else {
            /*
             * @formatter:off            
             * Possible URLs are:
             * https://server:port/path/collection/_git/repository                           (n=5)
             * https://server:port/path/collection/project/_git/repository                   (n=6) 
             * @formatter:on          
             */
            switch (n) {
                case 6:
                    project = pathItems[3];
                    path = '/' + pathItems[1] + '/' + pathItems[2];
                    break;
                case 5:
                    project = repository;
                    path = '/' + pathItems[1] + '/' + pathItems[2];
                    break;
                default:
                    return false;
            }
        }

        log.info("   Git repository has parsed as:"); //$NON-NLS-1$
        log.info(MessageFormat.format("          scheme: {0}", scheme == null ? "NULL" : scheme)); //$NON-NLS-1$ //$NON-NLS-2$
        log.info(MessageFormat.format("       authority: {0}", authority == null ? "NULL" : authority)); //$NON-NLS-1$ //$NON-NLS-2$
        log.info(MessageFormat.format("            path: {0}", path == null ? "NULL" : path)); //$NON-NLS-1$ //$NON-NLS-2$
        log.info(MessageFormat.format("         project: {0}", project == null ? "NULL" : project)); //$NON-NLS-1$ //$NON-NLS-2$
        log.info(MessageFormat.format("      repository: {0}", repository == null ? "NULL" : repository)); //$NON-NLS-1$ //$NON-NLS-2$

        serverUrl = URIUtils.newURI(uri.getScheme(), uri.getAuthority(), path, null, null).toString();

        return true;
    }

    public void removeProtocolHandlerArguments() {
        isAvailable = false;
    }

    public ICommand getRegistrationCommand() {
        if (!GitHelpers.isEGitInstalled(false)) {
            return null;
        }

        if (Platform.isCurrentPlatform(Platform.WINDOWS)) {
            return new ProtocolHandlerWindowsRegistrationCommand();
        }

        return null;
    }
}
